---
title: How far are cyclists willing to go to use a cycling path?
author: simon
date: '2020-01-28'
slug: map-matching-bike
categories:
  - R
  - bike
  - map-maptching
tags: []
keywords:
  - tech
---



```{r setup, include =F, echo =F}
#
# TODO : valider ceci : Chunk options must be written in one line; no line breaks are allowed inside chunk options;
# https://yihui.name/knitr/options/
knitr::opts_chunk$set(echo = FALSE, 
                      collapse = FALSE,
                      warning = FALSE,
                      error = FALSE,
                      message = FALSE,
                      fig.align= "center",
                      fig.width = 10,
                      highlight = TRUE,
                      cache = FALSE,
                      cache.lazy = FALSE) # fixes long vecto rnot supported quand on cache des gros éléments https://stackoverflow.com/questions/39417003/long-vectors-not-supported-yet-error-in-rmd-but-not-in-r-script
```

Hey everyone,

I have been looking for a use for [this open data that contains GPS data for ~ 5000 bike trips in Montreal](http://donnees.ville.montreal.qc.ca/dataset/trajets-individuels-velo-enregistre-mon-resovelo) for a while ago and here is the question I came up with:    *"How far are cyclists ready to go to use a safe road rather than an unsafe one?"*.  

I came up with the following methodology:  

* Find out how many kilometers are spent on each road class for the *shortest path possible * between the origin and destination  (eg: 10 kilometers on residential roads).  
* Find out how many kilometersare *actually spent on each road class* (eg: 7 kilometers on residential roads, 6 kilometers on cycling pathways).
* The ratio between the increase in cycling pathway  and the decrease in less-safe roads defines how much cycling pathways are preferred over less-safe roads.  

In my example, the ratio is 2.0, as the 6 kilometers on cycling pathways are used to reduce the distance on roads by 2x.

This turned out to be quite an undertaking.  Here is what I learned doing this.  

# Graphhopper  

Graphhopper ([github](https://github.com/graphhopper/graphhopper) is an "open source routing engine".  This means that  




```{r, include = F}
library(leaflet)
library(sf)
library(mapview)
library(tidyverse)
library(purrr)
#devtools::install_github("DavisVaughan/furrr") # github version required for future_walk2

library(furrr)
library(tictoc)
library(jsonlite)
plan(multiprocess, workers = availableCores()-1)
```

Get bike gps data
```{r, eval =F}
download.file("http://donnees.ville.montreal.qc.ca/dataset/77f30d2b-c786-45f0-9f33-ebdef46f3b4c/resource/2f05c452-6b63-4fba-8220-ac7104492074/download/trip5000.zip",
              destfile = here::here("content/post/data/downloads/trip5000.zip")
)

utils::unzip(here::here("content/post/data/downloads/trip5000.zip"),
             exdir = here::here("content/post/data/downloads/")
)


#  download.file("http://download.geofabrik.de/north-america/canada/quebec-latest.osm.pbf",
#                destfile = here::here("content/post/data/downloads/quebec-latest.osm.pbf")
# ) # 428.9 MB

```

Map data from OSM : https://download.geofabrik.de/north-america/canada/quebec.html


import gps data


```{r}
#z <- stplanr::line2pointsn(tripp5000$geometry[[1]])


# import data (linestring)
trip5000 <- sf::read_sf(here::here("content/post/data/downloads/trip5000.json")) # linestring 4881 lin

# convert linestring to multipoints
z <- trip5000 %>% 
  mutate( 
    points = map(geometry, ~ {
      mls <- sf::st_cast(., "MULTIPOINT") 
      data.frame(id = "prout", x = mls[,1], y = mls[,2])
    }))

```

```{r, eval = F}
# write each trip to a  a gpx bike names id_XXXX.gpx
tic()
furrr::future_walk2(z$id, z$points, ~ {
  pgirmess::writeGPX(.y, filename = here::here("content/post/data/interim/bike_gps/", paste0("id_", .x, ".gpx" )), type = "t")
}, progress= TRUE)
toc() # 2 minutes on 7 cores
```

We do indeed have X gpx files

```{r}
list_gpx <- tibble(filename = 
                     list.files(path = here::here("content/post/data/interim/bike_gps/"), 
                                pattern = "*.gpx")
)
```


# Install graphhopper map matching program and import Quebec map for use with bike vehicle  

We will now install the map-matching tool by graphhopper.  The instructions are included in the readme of the git repository  at  https://github.com/graphhopper/map-matching . 
Java 8 and Maven >=3.3 are required.

We modify slightly the instruction because the "recent_core" branch is required for the "vehicle=bike" option to work.  
We also download and import the openstreetmaps road network for the province of quebec.


```{r, eval = F, include = F, results = "hide"}
system(
  paste("cd ~/git/", 
        "git clone https://github.com/graphhopper/map-matching.git --branch 'recent_core'",
        "cd map-matching",
        "mvn package -DskipTests",
        "wget http://download.geofabrik.de/north-america/canada/quebec-latest.osm.pbf --quiet",
        "java -jar matching-web/target/graphhopper-map-matching-web-1.0-SNAPSHOT.jar import quebec-latest.osm.pbf --vehicle='bike'",
        sep = " && ")
)
```


# Match all bike trip gpx using graphhopper map matching program

This continues the instructions from the map matching readme

```{r, eval = F}
tic()
system("cd ~/git/map-matching && java -jar ~/git/map-matching/matching-web/target/graphhopper-map-matching-web-1.0-SNAPSHOT.jar match ~/git/snippets2/content/post/data/interim/bike_gps/*.gpx",  intern = TRUE)
toc() # 591.865 sec elapsed

```



some trips were not matched..  and return this error ::

Problem with file /home/simon/git/snippets2/content/post/data/interim/bike_gps/id_1035.gpx
java.lang.IllegalArgumentException: Sequence is broken for submitted track at time step 136 (2387 points). Too long distance to previous measurement? 6182m, observation:Observation{point=45.4757,-73.49115,0.0}, 6 candidates: [distance: 1.2748924992141155 to 45.4756918283334,-73.49116146917257,NaN, distance: 18.8576048599668 to 45.47556516846043,-73.49129669721343,NaN, distance: 1.179455381764211 to 45.47569018147931,-73.49115572348161,NaN, distance: 1.179455381764211 to 45.47569018147931,-73.49115572348161,NaN, distance: 1.143030762846551 to 45.475696624844865,-73.49116384693039,NaN, distance: 1.143030762846551 to 45.475696624844865,-73.49116384693039,NaN]. If a match is expected consider increasing max_visited_nodes.
at com.graphhopper.matching.MapMatching.computeViterbiSequence(MapMatching.java:386)
at com.graphhopper.matching.MapMatching.doWork(MapMatching.java:184)
at com.graphhopper.matching.cli.MatchCommand.run(MatchCommand.java:102)
at io.dropwizard.cli.Cli.run(Cli.java:78)
at io.dropwizard.Application.run(Application.java:93)
at com.graphhopper.matching.http.MapMatchingApplication.main(MapMatchingApplication.java:16)


list trips ids that have been matched
```{r}
matched_liste <- tibble(filename = 
                          list.files(path = here::here("content/post/data/interim/bike_gps/"), 
                                     pattern = "*.gpx.res.gpx")
) %>%
  mutate(id = str_extract(filename, "\\d+")) # 4859 matched trips 


```


```{r}
bind_rows_sf <- function(list_sf){
  sf::st_as_sf(data.table::rbindlist(list_sf)) 
}
```


# Results of map matching  

Let's see how well this map matching worked : 
```{r}
matched <- matched_liste %>% select(id) %>%
  mutate(matched = future_map(id, ~{
    st_read(here::here("content/post/data/interim/bike_gps/",paste0("id_", .x, ".gpx.res.gpx"))
            , layer = "track_points", quiet = TRUE)%>%
      mutate(group = .x) %>%
      group_by(group)%>%
      summarize(., do_union = FALSE) %>%
      st_cast("LINESTRING")
  }, progress = TRUE))



matched <- bind_rows_sf(matched$matched)

original_and_matched <- 
  bind_rows_sf(
    list(
      matched %>% 
        mutate(group = paste0(group, "_matched")), 
      z %>% select(group = id)
    )
  )


mapview(original_and_matched %>% arrange(group) %>% slice(11:20))
```

Its working fine!    As you can see, the 10044_matched trip  is matched to the  cycling lane on Rachel instead of the road.



# Routing   

Alright, now let's try to find what was the shortest route between the first and the last point.   

## Install graphhopper routing engine

The graphhopper routing engine is located at https://github.com/graphhopper/graphhopper

We install it following the quickstart guide for developpers (https://github.com/graphhopper/graphhopper/blob/0.13/docs/core/quickstart-from-source.md), because the quickstart guide using a *.jar file (https://github.com/graphhopper/graphhopper/blob/0.13/docs/web/quickstart.md) returns an error when using the bike vehicle.  

ça ça marche, mais ça fige la machine..


```{r, include = F}
system(
  paste("cd ~/git/", 
        "git clone git://github.com/graphhopper/graphhopper.git",
        "cd graphhopper",
        "cd web/src/main/resources/ && ZFILE=/tmp/gh.jar && wget -O $ZFILE 'https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.graphhopper&a=graphhopper-web&v=LATEST' && unzip $ZFILE assets/js/main.js && rm $ZFILE && cd ../../../..",
        "rm config-example.yml", 
        "wget https://gist.githubusercontent.com/SimonCoulombe/c4e4bb3af45ba6b4ccdd48aab561b2dc/raw/config-bike.yml",
        "cp ~/git/map-matching/quebec-latest.osm.pbf ~/git/graphhopper",
        "./graphhopper.sh -a web -i quebec-latest.osm.pbf  -c config-bike.yml" ,
        sep = " && ")
)
```


## Some code I couldnt get to work but saved for posterity

<!-- git clone https://github.com/graphhopper/graphhopper.git -->
<!-- cd graphhopper -->
<!-- docker build -t graphhopper:master . -->
<!-- docker run -d --name graphhopper -v ~/git/osm_data/data:/data -p 8989:8989 graphhopper:master -->


<!-- https://discuss.graphhopper.com/t/getting-graphhopper-to-work/3386/5 -->

<!-- Aug '18 -->

<!-- Once you have java installed, you should just be able to run commands similar to the following in the command prompt to get it to work locally. -->

<!-- cd ‘C:~directory with graphhopper files’ -->
<!-- start chrome http://localhost:8989/ 1 -->
<!-- java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=berlin-latest.osm.pbf -->

<!-- ‘*’ = filename e.g. graphhopper-web-0.5.0-with-dep.jar -->

<!-- Finally got it working on Windows (thanks maxo16): -->
<!-- C:\GraphHopper>java -jar graphhopper-web-0.10.0-with-dep.jar jetty.resourcebase=webapp config=config-example.properties datareader.file=berlin-latest.osm.pbf -->
<!-- BTW, would be really nice if someone could please post this into the quick start doc: -->
<!-- https://github.com/graphhopper/graphhopper/blob/master/docs/web/quickstart.md 14 -->
<!-- The link http://localhost:8989/ 5 brought up map of Berlin for me, everything seems to be fine. -->


<!-- java -jar *.jar jetty.resourcebase=webapp config=config-example.properties osmreader.osm=quebec-latest.osm.pbf -->

<!-- ### gmmm non -->
<!-- on va essayer  le quickstart guide  à https://github.com/graphhopper/graphhopper/blob/0.13/docs/web/quickstart.md -->

<!-- mkdir graphhopper -->
<!-- cd graphhopper -->
<!-- wget https://raw.githubusercontent.com/graphhopper/graphhopper/0.13/config-example.yml -->
<!-- cat config-example.yml | sed s/"graph.flag_encoders: car"/"graph.flag_encoders: bike"/ > config-bike.yml -->
<!-- wget https://graphhopper.com/public/releases/graphhopper-web-0.13.0.jar -->
<!-- wget http://download.geofabrik.de/europe/germany/berlin-latest.osm.pbf -->
<!-- java -Dgraphhopper.datareader.file=berlin-latest.osm.pbf -jar *.jar server config-bike.yml -->


<!-- ça marche pas pour les bikes. -->

<!-- # on va essayer le quick start guide for developpers  -->
<!-- https://github.com/graphhopper/graphhopper/blob/0.13/docs/core/quickstart-from-source.md -->


<!-- git clone git://github.com/graphhopper/graphhopper.git -->
<!-- cd graphhopper; -->
<!-- cd web/src/main/resources/ && ZFILE=/tmp/gh.jar && wget -O $ZFILE "https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.graphhopper&a=graphhopper-web&v=LATEST" && unzip $ZFILE assets/js/main.js && rm $ZFILE && cd ../../../.. -->
<!-- wget https://raw.githubusercontent.com/graphhopper/graphhopper/0.13/config-example.yml -->
<!-- cat config-example.yml | sed s/"car"/"bike"/ > config-bike.yml -->
<!-- ./graphhopper.sh -a web -i europe_germany_berlin.pbf # -c config-bike.yml -p bike  -->

<!-- holy shit ça marche on recommence avec quebec pour tester la piste cyclable des outaouais.. -->

<!-- git clone git://github.com/graphhopper/graphhopper.git -->
<!-- cd graphhopper; -->
<!-- cd web/src/main/resources/ && ZFILE=/tmp/gh.jar && wget -O $ZFILE "https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.graphhopper&a=graphhopper-web&v=LATEST" && unzip $ZFILE assets/js/main.js && rm $ZFILE && cd ../../../.. -->
<!-- #wget https://raw.githubusercontent.com/graphhopper/graphhopper/0.13/config-example.yml -->
<!-- #cat config-example.yml | sed s/"car"/"bike"/ > config-bike.yml -->
<!-- wget http://download.geofabrik.de/north-america/canada/quebec-latest.osm.pbf -->
<!-- ./graphhopper.sh -a web -i quebec-latest.osm.pbf  -c config-example.yml ## le secret c'est de pas mettre -p bike...   # à la place je modifie manuellement config-example pour avoir car, bike -->

<!-- ## voici mon config example gossé avec amour  : wget https://gist.githubusercontent.com/SimonCoulombe/c4e4bb3af45ba6b4ccdd48aab561b2dc/raw/config-example.yml -->


# docker code that works 

git clone git://github.com/graphhopper/graphhopper.git
cd graphhopper
rm config-example.yml 
wget https://gist.githubusercontent.com/SimonCoulombe/c4e4bb3af45ba6b4ccdd48aab561b2dc/raw/config-bike.yml
mv config-bike.yml config-example.yml
rm Dockerfile
wget https://gist.githubusercontent.com/SimonCoulombe/ac4acfffdc5a4ac9a1a262703bfc5911/raw/Dockerfile # mon dockerfile utilise mon config et le québec
docker build -t graphhopper:simon .
cd ~
mkdir docker_volumes
cd docker_volumes
mkdir graphhopper
docker run -d --name graphhopper -v ~/docker_volumes/graphhopper/data:/data -p 8989:8989 --restart unless-stopped graphhopper:simon
## attendre un moment parce que  il va 1) downloader le osm pour le québec et 2) se créer une cache. 
#  docker logs graphhopper
# ## using java 1.8.0_242 (64bit) from /usr/local/openjdk-8
# ./graphhopper.sh: line 138: mvn: command not found
# File not found '/data/north-america_canada_quebec.pbf'. Press ENTER to get it from: http://download.geofabrik.de/north-america/canada/quebec-latest.osm.pbf
# Press CTRL+C if you do not have enough disc space or you don't want to download several MB.
# ## now downloading OSM file from http://download.geofabrik.de/north-america/canada/quebec-latest.osm.pbf and extracting to /data/north-america_canada_quebec.pbf



# ok on essaie l'API basé sur mon service docker

documentation du web api du routing engine :
https://github.com/graphhopper/graphhopper/blob/0.13/docs/web/api-doc.md

```{r}

api_results <- fromJSON("http://localhost:8989/route?point=45.381271%2C-75.809054&point=45.380759%2C-75.82253&vehicle=bike&details=road_class&points_encoded=false")
api_results$paths$instructions %>% .[[1]] %>% select(distance)#%>% head(-1) # distances sur chacun des 3 segments
api_results$paths$instructions %>% .[[1]] %>% select(interval) #%>% head(-1) # distances sur chacun des 3 segments
api_results$paths$details$road_class[[1]][,3] # type de route correspondant aux distances
api_results$paths$points$coordinates[[1]] %>% 
  as_tibble() %>% 
  rename(lon = V1, lat= V2) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  mutate(group = "groupe") %>%
  group_by(group) %>%
  summarize(., do_union = FALSE) %>%
  st_cast("LINESTRING") %>% 
  mapview() # extraire les points du chemin le plus court
```


# Route the map-matched points to get the actual road class travelled.  

http://localhost:8989/route?point=45.381271%2C-75.809054&point=45.380759%2C-75.82253
```{r}
matched$geometry[[1]] %>% st_coordinates %>% as_tibble() %>% mutate(texte = paste0("point=", Y, "%2C", X))  %>% pull(texte) %>% paste(., collapse="&")
```
nice.. on va faire ça sur tout le modne


quand les URL sont trops long, la fonction fromJSON pense que je lui ai donné le texte du json au lieu de l'url du json.
pour éviter ça, on metre fromJSON(url(filesURL))  , tel qu'expliqué ici:  
https://github.com/jeroen/jsonlite/issues/230


il y aquand même des trajets trops long même pour firefox (error URI too long) pour id 1015 qui a genre 400 points matchés
test: 275 ça marche, 300 ça marche pas ..
on va garder entre 250 et 252 points au hasard.. incluantl e premier et le dernier


```{r}
generate_api_call <- function(geometry, origin_destination_only = FALSE){ 
  
  if(origin_destination_only == FALSE){
    paste0(
      "http://localhost:8989/route?",
      st_coordinates(geometry) %>%
        as_tibble() %>% 
        mutate(rownum = row_number(),
               random = runif(nrow(.)),
               rank = rank(random)) %>%
        filter(rownum == 1 | rownum == nrow(.) | rank < 250) %>%
        mutate(
          texte = paste0(
            "point=", Y, "%2C", X)
        )  %>% pull(texte) %>% paste(., collapse="&"),
      "&vehicle=bike&details=road_class&points_encoded=false"
    )
  } else if(origin_destination_only == TRUE){
    paste0(
      "http://localhost:8989/route?",
      st_coordinates(geometry) %>%
        as_tibble() %>% 
        slice(1, n()) %>% # keep first and last coordinates
        mutate(rownum = row_number(),
               random = runif(nrow(.)),
               rank = rank(random)) %>%
        filter(rownum == 1 | rownum == nrow(.) | rank < 250) %>%
        mutate(
          texte = paste0(
            "point=", Y, "%2C", X)
        )  %>% pull(texte) %>% paste(., collapse="&"),
      "&vehicle=bike&details=road_class&points_encoded=false"
    )
    
  }
}

get_api_results <- function(geometry, origin_destination_only = FALSE){
  fromJSON(
    url(
      generate_api_call(geometry = geometry, 
                        origin_destination_only = origin_destination_only)
    )
  )
}
```

```{r}
tic()
matched_routed <- matched %>%
  mutate(length_matched = st_length(geometry) %>% as.numeric(.)) %>%
  mutate(
    api_results = future_map(geometry, 
                             ~ get_api_results(geometry = .x, 
                                               origin_destination_only = FALSE), 
                             progress = TRUE)
  ) 
toc()
write_rds(matched_routed, here::here("content/post/data/interim/", "matched_routed.rds"))
```


## ok on va jouer avec les api results

```{r}
matched_routed <- read_rds(here::here("content/post/data/interim/", "matched_routed.rds"))
```


```{r}
get_routed_linestring <- function(api_results){
  api_results$paths$points$coordinates[[1]] %>% 
    as_tibble() %>% 
    rename(lon = V1, lat= V2) %>%
    st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
    summarize(., do_union = FALSE) %>%
    st_cast("LINESTRING")
}
```

```{r}
matched_routed_linestrings <-
  future_map(matched_routed$api_results, ~ get_routed_linestring(.x)) %>%
  bind_rows_sf() %>%
  add_column(group = matched_routed$group,
             api_results = matched_routed$api_results,
             length_matched = matched_routed$length_matched)  %>%
  mutate(length_routed_matched = st_length(geometry) %>% as.numeric()  )%>% 
  select(group, everything())   ## remettre group avant geometry  11s
```

##comparer la routé-mapmatché à la mapmatché
```{r}
bind_rows_sf(
  list(
    matched_routed_linestrings[28,] %>% mutate(group = paste0("matched_routed_", group)) %>% select(group),
    matched[28,] %>% mutate(group = paste0("matched_", group)) %>% select(group)
  )
) %>% mapview()
```

# sortir les distances par type de route pour la matché-routé  pour une personne

```{r}
get_distances_from_api_results <- function(api_results){
  tibble(
    distance = api_results$paths$instructions[[1]] %>% pull(distance),
    point_from = map(api_results$paths$instructions[[1]]$interval, ~ .x[1]) %>% unlist(),
    point_to   = map(api_results$paths$instructions[[1]]$interval, ~ .x[2]) %>% unlist(),
  )
}

get_road_classes_from_api_results <- function(api_results){
  tibble(
    from       = api_results$paths$details$road_class[[1]][,1], # from point   
    to         = api_results$paths$details$road_class[[1]][,2], # to point 
    road_class = api_results$paths$details$road_class[[1]][,3]  # type de route
  )
}

get_each_point_road_class_from_road_classes <- function(road_classes){
  road_classes %>% 
    mutate(data = map2(as.numeric(from), as.numeric(to), ~ {
      data_frame( 
        point_from = 
          seq(
            from= .x,
            to = .y-1 ,
            by = 1
          ))
    })) %>% unnest(data) %>%
    select(-from, -to)
}

```


```{r}
tic()
matched_routed2 <- matched_routed_linestrings %>%
  mutate( ratio = length_matched / length_routed_matched,
          distances = future_map(api_results, ~get_distances_from_api_results(.x)),
          road_classes = future_map(api_results, ~ get_road_classes_from_api_results(.x) ),
          road_classes_points = future_map(road_classes, ~ get_each_point_road_class_from_road_classes(.x)),
          distance_by_road_class = future_pmap(
            list(distances, road_classes_points, ratio),
            function(distances, road_classes_points, ratio){
              distances %>% 
                left_join(road_classes_points) %>%
                group_by(road_class) %>%
                summarise(distance = sum(distance)) %>%
                mutate(corrected_distance = distance * ratio) %>%  ## correct for distance inflation when routing does funny loops
                filter(!is.na(road_class))
            })
  )
toc()
write_rds(matched_routed2, here::here("content/post/data/interim/", "matched_routed2.rds"))
```



.. ok let's summarise that shit.
```{r}
matched_routed2 %>%  st_set_geometry(NULL) %>% pull(distance_by_road_class) %>% bind_rows() %>%
  group_by(road_class) %>%
  summarise(distance = sum(distance),
            corrected_distance = sum(corrected_distance)) %>%
  ungroup() %>%
  mutate(pct = 100 * corrected_distance / sum(corrected_distance)) %>%
  arrange(-corrected_distance) %>%
  knitr::kable()
```


Ok, so we know what cycled distance was *actually* spent on each road type.  Now we must find out how much *would have been had they chosen the shortest path*.  

# Finding 5000 shortest paths  between origin and destination  

.. fuck.. what about origin = destination (a stroll that comes back home?  ) let's ditch them...

```{r}
matched_shortest_route <- matched %>%
  mutate(length_matched = st_length(geometry) %>% as.numeric(.)) %>%
  mutate(
    api_results = future_map(geometry, 
                             ~ get_api_results(geometry = .x, 
                                               origin_destination_only = TRUE), 
                             progress = TRUE)
  ) 


matched_shortest_route_linestrings <-
  future_map(matched_shortest_route$api_results, ~ get_routed_linestring(.x)) %>%
  bind_rows_sf() %>%
  add_column(group = matched_shortest_route$group,
             api_results = matched_shortest_route$api_results,
             length_matched = matched_shortest_route$length_matched)  %>%
  mutate(length_routed_matched = st_length(geometry) %>% as.numeric()  )%>% 
  select(group, everything())   ## remettre group avant geometry  11s

matched_shortest_route2 <- matched_shortest_route_linestrings %>% 
  filter(length_routed_matched >0) %>%
  mutate( ratio = length_matched / length_routed_matched,
          distances = future_map(api_results, ~get_distances_from_api_results(.x)),
          road_classes = future_map(api_results, ~ get_road_classes_from_api_results(.x) ),
          road_classes_points = future_map(road_classes, ~ get_each_point_road_class_from_road_classes(.x)),
          distance_by_road_class = future_pmap(
            list(distances, road_classes_points, ratio),
            function(distances, road_classes_points, ratio){
              distances %>% 
                left_join(road_classes_points) %>%
                group_by(road_class) %>%
                summarise(distance = sum(distance)) %>%
                mutate(corrected_distance = distance * ratio) %>%  ## correct for distance inflation when routing does funny loops
                filter(!is.na(road_class))
              
            }
          )
  )


matched_shortest_route2 %>% st_set_geometry(NULL) %>% pull(distance_by_road_class) %>% bind_rows() %>%
  group_by(road_class) %>%
  summarise(distance = sum(distance),
            corrected_distance = sum(corrected_distance)) %>%
  ungroup() %>%
  mutate(pct = 100 * corrected_distance / sum(corrected_distance)) %>%
  arrange(-corrected_distance) %>%
  knitr::kable()
```



# OLD : gosser avec 1 seul api result  

```{r}
api_results <- fromJSON("http://localhost:8989/route?point=45.554648%2C-73.65153&point=45.555255%2C-73.653636&point=45.559321%2C-73.651223&point=45.559055%2C-73.650315&point=45.558876%2C-73.649942&point=45.557903%2C-73.646625&point=45.554617%2C-73.634926&point=45.554482%2C-73.634482&point=45.554262%2C-73.633858&point=45.554033%2C-73.633317&point=45.55376%2C-73.632767&point=45.553498%2C-73.632321&point=45.553216%2C-73.631907&point=45.552835%2C-73.631426&point=45.55245%2C-73.630995&point=45.55187%2C-73.630521&point=45.551361%2C-73.630183&point=45.550315%2C-73.629538&point=45.550174%2C-73.629414&point=45.549992%2C-73.629044&point=45.548135%2C-73.6248&point=45.548104%2C-73.624855&point=45.547867%2C-73.62513&point=45.547769%2C-73.62516&point=45.546912%2C-73.625879&point=45.545966%2C-73.623742&point=45.544961%2C-73.621405&point=45.545408%2C-73.621001&point=45.544948%2C-73.619991&point=45.541693%2C-73.612651&point=45.540127%2C-73.60917&point=45.538613%2C-73.605703&point=45.53705%2C-73.602222&point=45.535666%2C-73.599076&point=45.53337%2C-73.59398&point=45.533716%2C-73.593658&point=45.533748%2C-73.593583&point=45.533805%2C-73.59351&point=45.533856%2C-73.593479&point=45.533963%2C-73.59346&point=45.534002%2C-73.593422&point=45.534043%2C-73.59328&point=45.533018%2C-73.591322&point=45.532897%2C-73.591128&point=45.532592%2C-73.590471&point=45.532534%2C-73.590425&point=45.532505%2C-73.590341&point=45.532019%2C-73.590777&point=45.531419%2C-73.5894&point=45.531184%2C-73.588953&point=45.531052%2C-73.589006&point=45.530076%2C-73.586827&point=45.532416%2C-73.584746&point=45.532194%2C-73.584279&point=45.532158%2C-73.584312&point=45.530842%2C-73.5815&point=45.528179%2C-73.575714&point=45.526302%2C-73.577464&vehicle=bike&details=road_class&points_encoded=false")
api_results$paths$instructions %>% .[[1]] %>% select(distance) #%>% head(-1) # distances sur chacun des 3 segments
api_results$paths$instructions %>% .[[1]] %>% select(interval)  
api_results$paths$details$road_class[[1]][,3] # type de route correspondant aux distances
routed_match <- api_results$paths$points$coordinates[[1]] %>% 
  as_tibble() %>% 
  rename(lon = V1, lat= V2) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  mutate(group = "groupe") %>%
  group_by(group) %>%
  summarize(., do_union = FALSE) %>%
  st_cast("LINESTRING") 


```

ok les 3 ensemble?
```{r}
allthree <- sf::st_as_sf(data.table::rbindlist(
  list(
    matched %>%  filter(group==1000) %>%
      mutate(group = paste0(group, "_matched")),
    routed_match %>%  
      mutate(group = paste0(group, "_matched_routed")), 
    z %>% filter(id == 1000) %>% select(group = id)
  )
)
) 

mapview(allthree, alpha =0.6)

```
hmmm , il fait des drôles de détour mon matched..

```{r}
matched_points <- matched$geometry[[1]]  %>% st_coordinates %>% 
  as_tibble() %>% 
  rename(lon = X, lat= Y) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)  %>%
  mutate(group= "matched_points") %>%
  group_by(group) %>%
  summarize(., do_union = FALSE) %>%
  st_cast("MULTIPOINT")  
```

```{r}
allthree <- sf::st_as_sf(data.table::rbindlist(
  list(
    matched %>%  filter(group==1000) %>%
      mutate(group = paste0(group, "_matched")),
    routed_match %>%  
      mutate(group = paste0(group, "_matched_routed")), 
    matched_points
  )
)
) 

mapview(allthree, alpha =0.6)

```
ah bin on ça se peut pas combiner desm ultipoints avec des lignes


#----- vieux cossins
hey ça marche
```{r}
original <- st_read("original.gpx"
                    , layer = "track_points") %>% mutate(group = "original") %>%
  group_by(group)%>%
  summarize(., do_union = FALSE) %>%
  st_cast("LINESTRING")

matched <- st_read("original.gpx.res.gpx"
                   , layer = "track_points")%>% mutate(group = "matched") %>%
  group_by(group)%>%
  summarize(., do_union = FALSE) %>%
  st_cast("LINESTRING") 


sf::st_as_sf(data.table::rbindlist(list(original, matched))) %>%
  mapview()

```


```{r}
sf::st_write(tripp5000 %>% head(1),
             dsn="trip5000.gpx",
             layer="track_points", driver="GPX",
             dataset_options="GPX_USE_EXTENSIONS=YES"
)
```

```{r}
l <- routes_fast_sf[2:4, ]
lpoints <- line2points(l)
lpoints_sfc <- line2points(sf::st_geometry(l))
identical(lpoints, lpoints_sfc)
lpoints2 <- line2pointsn(l)
plot(sf::st_geometry(lpoints), pch = lpoints$id, cex = lpoints$id, col = "black")
plot(lpoints2$geometry, add = TRUE)
# in sp data forms (may be depreciated)
l <- routes_fast[2:4, ]
lpoints <- line2points(l)
lpoints2 <- line2pointsn(l)
plot(lpoints, pch = lpoints$id, cex = lpoints$id)
points(lpoints2)
```

