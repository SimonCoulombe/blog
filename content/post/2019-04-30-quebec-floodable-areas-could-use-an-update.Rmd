---
title: Quebec floodable areas could use an update...
author: Simon
date: '2019-04-30'
slug: quebec-floodable
categories:
  - R
  - flood
  - opendata
tags: []
keywords:
  - tech
thumbnailImage: "/post/2019-04-30-quebec-floodable-areas-could-use-an-update_files/Screenshot_20190430_101705.png" 
thumbnailImagePosition: left
---
UPDATE 2020: addr.country,  n'existe plus dans les buildings de osm data.  aussi il faut faire st_collection_extract(type="POLYGON") car mes intersections ont commencé à retourner des geometry collection
This morning I heard an annoucement from the provincial government telling me that preparing for floods is my responsibility, that I should check if my house is in a floodable area and that I should visit quebec.ca/inondations for more information.

We currently have multiple major flooding events in the city of Gatineau.  I used open data about buildings (package osmdata), [floodable area](https://www.donneesquebec.ca/recherche/fr/dataset/vgat-zones-inondables-norme-v1) and [flooded areas](https://www.donneesquebec.ca/recherche/fr/dataset/cartographie-des-inondations-printemps-2019) to figure out what percentage of flooded homes actually are in a floodable area.  Turns out that more than half of the flooded homes were outside the floodable areas and had no reason to prepare.  

This is a dangerous situation and definitely needs fixing.

As usual, the code is available on github.  Code snippets I will be coming back to involve the chain were I dropped the worst polygons using st_is_valid(reason=TRUE), fixed the fixable polygons  using st_make_valid(), then casted the result usint st_cast("MULTIPOLYGON") to make everything digestable by leaflet.    Another useful snippet is names(st_geometry(all_builds )) = NULL , because the data generated by osmdata_sf has named geometry, which leaflet doesnt like.  


```{r setup, include =F}

# TODO : valider ceci : Chunk options must be written in one line; no line breaks are allowed inside chunk options;
# https://yihui.name/knitr/options/

knitr::opts_chunk$set(echo = FALSE,
                      collapse = TRUE,
                      warning = FALSE,
                      error = FALSE,
                      message = FALSE,
                      fig.align= "center",
                      fig.width = 10,
                      highlight = TRUE,
                      cache = FALSE,
                      cache.lazy = FALSE) # fixes long vector not supported quand on cache des gros éléments https://stackoverflow.com/questions/39417003/long-vectors-not-supported-yet-error-in-rmd-but-not-in-r-script
```


```{r libraries, echo=F,  include = F}

library(osmdata) # get building data
library(tidyverse)
library(sf) 
library(leaflet) # slippy maps
library(rmapzen) # static map  with nice tiles
library(furrr) # multicore mapping
plan(multiprocess, workers = availableCores()-1)
library(jsonlite) # load json
library(lwgeom) # st_make_valid for zone in ondable
library(widgetframe) # add leaflets to blog
library(tictoc) # timing of long process

switch_generate_interim_data <- FALSE
```

```{r floodable_areas, echo=F,  include = F}

if(switch_generate_interim_data){
# zones inondables  ----
# https://www.donneesquebec.ca/recherche/fr/dataset/vgat-zones-inondables-norme-v1

download.file("http://www.gatineau.ca/upload/donneesouvertes/Zones%20inondables%20norme.json",
              destfile = here::here("content/post/data/downloads/zones_inondables_norme.json"))


inondable <- st_read(here::here("content/post/data/downloads/zones_inondables_norme.json"))  #%>% 
# leaflet ne fonctionne plus apres st_make_valid parce que ça crée des geometrrycollections
# c'est facile de convertir les geometrycollections to multipolygons avec st_cast
# mais la conversion plante car certains polygons sont pas valides..   Une solution est de dropper les 2 lignes de inondables pour
# les quelles on n'a pas de raison pour être invalide..

inondable2 <- inondable[!is.na(st_is_valid(inondable, reason= TRUE)),]  %>%   
  lwgeom::st_make_valid() %>% 
  st_cast("MULTIPOLYGON") 

inondable3 <- inondable2 %>% mutate( dummy = 1 ) %>% group_by(dummy) %>% summarise(dummy2= 1)
inondable3_type <- inondable2 %>%  group_by(TYPE) %>% summarise(dummy= 1) %>% select(-dummy)

#      st_cast("MULTIPOLYGON")  # caster les collections en multipolygon% https://www.r-spatial.org/r/2017/03/19/invalid.html
# %>%
#      mutate( dummy = 1 ) %>% group_by(dummy) %>% summarise(dummy2= 1)

write_rds(inondable3, here::here("content/post/data/interim", "inondable3.rds"))
write_rds(inondable3_type, here::here("content/post/data/interim/","inondable3_type.rds"))
} else {
  inondable3 <- read_rds(here::here("content/post/data/interim/", "inondable3.rds"))
  inondable3_type <- read_rds(here::here("content/post/data/interim/", "inondable3_type.rds"))
}
```


```{r flooded_area, echo=F,  include = F}

if(switch_generate_interim_data){
# actual flooded area, April 29th ----
download.file("https://www.donneesquebec.ca/recherche/fr/dataset/df99bb67-317c-435b-8f9a-50de5fa9729a/resource/53ecf495-9320-47b4-9c9f-7edb9cbba0c5/download/mspinondations2019eaulibre20190427.zip",
              destfile= here::here("content/post/data/downloads/", "mspinondations2019eaulibre20190427.zip"))
utils::unzip(here::here("content/post/data/downloads/", "mspinondations2019eaulibre20190427.zip"),
             exdir = here::here("content/post/data/downloads/"))

# sf_inond = inondation sf data frame
sf_inond <- sf::st_read(here::here("content/post/data/downloads/", "msp_inondations2019_eaulibre.shp")) %>%
  sf::st_transform( crs = 4326)

# data_inond = remove geometry ( faster calculations, skim, etc.)
data_inond <- sf_inond
st_geometry(data_inond) <- NULL
data_inond %>% skimr::skim()
data_inond %>% count(classe_des)



# get only non-normal water levels  in Gatineau
inond <- sf_inond %>%  
  filter(secteur  == "Gatineau")%>% 
  filter(classe_des != "Plan d'eau permanent") 

# dissolve the polygons into 1 large  multipolygon
flooded_area <- inond %>% group_by(secteur) %>% 
  summarise(m =2 ) 
write_rds(flooded_area, here::here("content/post/data/interim/", "flooded_area.rds"))
} else {
  flooded_area <- read_rds(here::here("content/post/data/interim/", "flooded_area.rds"))
}

```


```{r buildings, , echo=F,  include = F}
#  buildings data ----
if(switch_generate_interim_data){

bbox <- st_bbox(flooded_area)

buildings_list <- opq(bbox = bbox) %>%
   add_osm_feature(key = 'building') %>%
   osmdata_sf()

write_rds(buildings_list, here::here("content/post/data/interim/", "buildings_list.rds"))
buildings_list <- read_rds( here::here("content/post/data/interim/", "buildings_list.rds"))


avec_adresse <- map(buildings_list[ c(4,5,6,8)],~ .x %>%   # 4 to 8 = points, lines, polygons, multilines multipolygons
                      # mais 7 = multilines = null
                      
                      filter(addr.city == "Gatineau")   %>% 
                      select(osm_id, name, addr.city, # EDIT 2020: addr.country,  n'existe plus
                             addr.housenumber,
                             addr.postcode  , addr.source,  addr.street, source))

# rbind pour binder les rows d'un sf dataframe       
all_builds <- rbind(avec_adresse[[1]], avec_adresse[[2]], avec_adresse[[3]], avec_adresse[[4]])


names(st_geometry(all_builds )) = NULL

write_rds(all_builds, here::here("content/post/data/interim/", "all_builds.rds"))
} else {
  all_builds <- read_rds(here::here("content/post/data/interim/", "all_builds.rds"))
}

```


```{r flooded_buildings, echo=F,  include = F}
# get flooded buildings ----
if(switch_generate_interim_data){
#chunks pour voir quels buildings sot floodés
chunks <- tibble(osm_id = all_builds$osm_id) %>%  mutate (chunk = row_number() %% 24) %>% 
  group_by(chunk) %>% nest()

tic()
# find which buildings have been flooded ( 5 minutes on 8 cores ryzen 1700)
# est-ce que le polygon du building intersect le flood?
z <- chunks %>% 
  mutate( newdata = future_map(data, function(X) {
    chunk_builds <- all_builds %>% 
      filter(osm_id %in% X$osm_id)  
    
    flooded <- st_intersects(chunk_builds, flooded_area)  %>% 
      map(. , any) %>% 
      unlist()
    tibble(osm_id = X$osm_id,  flooded = flooded)
  }
  
  ))
toc()
write_rds(z, here::here("content/post/data/interim/", "z.rds"))
z <- read_rds(here::here("content/post/data/interim/", "z.rds"))

# keep only flooded buildings
flooded_buildings  <- all_builds %>% inner_join(bind_rows(z$newdata)%>% filter(flooded == TRUE))
write_rds(flooded_buildings, here::here("content/post/data/interim/", "flooded_buildings.rds"))
} else {
  flooded_buildings <- read_rds(here::here("content/post/data/interim/", "flooded_buildings.rds"))
}

```


```{r were_flooded_buildings_floodable, echo=F,  include = F}

if(switch_generate_interim_data){
# parmi les flooded_buildings, qui était zoné inondable? ----
chunks2 <- tibble(osm_id = flooded_buildings$osm_id) %>%  mutate (chunk = row_number() %% 24) %>% 
  group_by(chunk) %>% nest()


tic()
zz <- chunks2 %>% 
  mutate( newdata = future_map(data, function(X) {
    chunk_builds <- flooded_buildings %>% 
      filter(osm_id %in% X$osm_id)  
    
    inondable <- st_intersects(chunk_builds, inondable3)  %>%  # besoin de st_make_valid, donc utilise inondable2
      map(. , any) %>% 
      unlist()
    tibble(osm_id = X$osm_id,  inondable = inondable)
  }
  
  ))
toc()

flooded_floodable <- flooded_buildings %>% 
  left_join(bind_rows(zz$newdata)) %>% 
  mutate(zone_inondable= ifelse(inondable, "Inondable", "Pas zoné inondable"))

write_rds(flooded_floodable, here::here("content/post/data/interim/", "flooded_floodable.rds"))
} else {
  flooded_floodable <- read_rds(here::here("content/post/data/interim/", "flooded_floodable.rds"))
}

```

```{r split_flood_in_floodable_areas, echo=F, include= F}
if(switch_generate_interim_data){
inondation_zone20 <- st_intersection(flooded_area, inondable3_type %>% filter(TYPE == "20"))%>% 
  mutate(inondable = "20 ans")

inondation_zone100 <- st_intersection(flooded_area, inondable3_type %>% filter(TYPE == "100"))%>% 
  mutate(inondable = "100 ans")

inondation_paszone <- st_difference(flooded_area, inondable3) %>% mutate(inondable = "Non-inondable") 

inondations <- rbind(inondation_zone20 %>% select(secteur, inondable),
                     inondation_zone100 %>% select(secteur, inondable), 
                     inondation_paszone %>% select(secteur, inondable)) 

write_rds(inondations, here::here("content/post/data/interim/", "inondations.rds"))
} else {
  inondations <- read_rds(here::here("content/post/data/interim/", "inondations.rds"))
}

```

```{r map, echo=F}


# pct flo
pct_inondable <- mean(flooded_floodable$inondable)
pct_noninondable = 1- pct_inondable

nb_inonde = nrow(flooded_floodable)
pal <- colorFactor("viridis", c("Inondable", "Pas zoné inondable"), reverse = TRUE)

pal2 <- colorFactor(c("deepskyblue", "deepskyblue2", "deepskyblue4"), c("20 ans", "100 ans","Non-inondable" ))

mymap <- leaflet(flooded_floodable) %>%  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data= inondations %>% st_collection_extract(type="POLYGON"),color = ~pal2(inondable),
              label = ~ inondable,
              weight = 0,
              fillOpacity = 0.8 ) %>%
  addPolygons(data= flooded_floodable  %>% st_collection_extract(type="POLYGON") ,
              color = ~pal(zone_inondable),
              label = ~ paste0( addr.housenumber, " ", addr.street , ",  ", zone_inondable) ) %>%
  addLegend("bottomright", data= flooded_floodable, pal = pal, values = ~zone_inondable,
            title = paste0(  round(pct_noninondable* 100,1), " % des ", nb_inonde, " maisons inondées en avril 2019 étaient hors des zones inondables."),
            opacity = 1)%>%
  addLegend("bottomleft", data= inondations, pal = pal2, values = ~inondable,
            title = "Étendue des inondations au 29 avril 2019, selon le zonage de mars 2019",
            opacity = 1)


widgetframe::frameWidget(mymap, width = '95%')
            
```

